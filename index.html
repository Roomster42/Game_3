<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Verifica Posizione – UTM (WGS84)</title>
<style>
  :root{
    --bg:#0f172a; --panel:#111827; --muted:#94a3b8; --accent:#22c55e; --danger:#ef4444; --card:#0b1220; --ring:#60a5fa;
  }
  *{box-sizing:border-box}
  body{margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial; background:radial-gradient(1200px 700px at 80% -10%,#1e293b 0%,var(--bg) 60%); color:#e5e7eb; min-height:100dvh; display:flex; align-items:center; justify-content:center; padding:24px;}
  .wrap{width:100%; max-width:840px;}
  .card{background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.02)); border:1px solid rgba(255,255,255,.08); backdrop-filter: blur(6px); border-radius:20px; padding:24px; box-shadow:0 20px 60px rgba(2,6,23,.45);}
  h1{margin:0 0 8px; font-size:clamp(22px,5vw,34px); letter-spacing:.2px}
  p.lead{margin:0 0 16px; color:var(--muted)}
  button{appearance:none; border:none; background:conic-gradient(from 120deg,#22c55e,#16a34a,#22c55e); color:#052e16; font-weight:700; padding:14px 18px; border-radius:14px; cursor:pointer; width:100%; font-size:18px; box-shadow:0 10px 30px rgba(34,197,94,.25);}
  button:active{transform:translateY(1px)}
  .row{display:grid; grid-template-columns:1fr; gap:14px; margin-top:16px}
  .out{background:var(--card); border:1px solid rgba(255,255,255,.08); border-radius:14px; padding:14px}
  .label{color:var(--muted); font-size:12px; letter-spacing:.4px; text-transform:uppercase}
  .value{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace; font-size:15px; margin-top:6px; word-break:break-word}
  .status{margin-top:12px; padding:14px; border-radius:12px; border:1px solid rgba(255,255,255,.08)}
  .ok{background:rgba(34,197,94,.12); border-color:rgba(34,197,94,.35); color:#bbf7d0}
  .bad{background:rgba(239,68,68,.12); border-color:rgba(239,68,68,.35); color:#fecaca}
  .linkbar{margin-top:18px; display:flex; gap:12px; flex-wrap:wrap}
  .linkbar a{color:#93c5fd; text-decoration:none; background:rgba(59,130,246,.12); padding:8px 12px; border-radius:12px; border:1px solid rgba(59,130,246,.35)}
  .foot{margin-top:16px; color:var(--muted); font-size:12px}
</style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Verifica la tua posizione</h1>
      <p class="lead">Sistema di controllo distanza dai punti obiettivo (raggio 30&nbsp;m). Coordinate in UTM per debug.</p>
      <button id="btn">Verifica la tua posizione</button>
      <div class="row">
        <div class="out">
          <div class="label">Coordinate GPS (UTM – WGS84)</div>
          <div id="coord" class="value">—</div>
        </div>
        <div class="out">
          <div class="label">Esito</div>
          <div id="esito" class="status">Premi il bottone per iniziare.</div>
        </div>
      </div>
      <div class="linkbar">
        <a href="verifica_codice.html">Hai un codice? Verificalo qui</a>
      </div>
      <div class="foot">Suggerimento: consenti l'accesso alla posizione. Funziona anche in PWA/standalone se salvato sul dispositivo.</div>
    </div>
  </div>

<script>
/* --- UTM/WGS84 conversion utilities (no external deps) ---
   Based on standard formulas (WGS84 ellipsoid; zone-wide accuracy for gameplay).
*/
const WGS84 = { a: 6378137.0, f: 1/298.257223563 };
WGS84.b = WGS84.a*(1-WGS84.f);
WGS84.e2 = 2*WGS84.f - WGS84.f*WGS84.f;
WGS84.ep2 = WGS84.e2/(1-WGS84.e2);
const k0 = 0.9996;

function latLonToUTM(latDeg, lonDeg){
  const lat = latDeg*Math.PI/180;
  const lon = lonDeg*Math.PI/180;
  const zone = Math.floor((lonDeg + 180)/6) + 1;
  const lambda0 = ((zone*6 - 183) * Math.PI/180);
  const e2 = WGS84.e2, ep2 = WGS84.ep2, a=WGS84.a;
  const N = a/Math.sqrt(1 - e2*Math.sin(lat)**2);
  const T = Math.tan(lat)**2;
  const C = ep2*Math.cos(lat)**2;
  const A = Math.cos(lat)*(lon - lambda0);
  // Meridional arc
  const n = WGS84.f/(2-WGS84.f);
  const A0 = 1 + (n**2)/4 + (n**4)/64;
  const A2 = (3/2)*(n - (n**3)/8 - (n**5)/64);
  const A4 = (15/16)*(n**2 - (n**4)/4 - (3*n**6)/128);
  const A6 = (35/48)*(n**3 - (5*n**5)/16);
  const A8 = (315/512)*(n**4 - (7*n**6)/32);
  const s = WGS84.b*k0*(A0*lat - A2*Math.sin(2*lat) + A4*Math.sin(4*lat) - A6*Math.sin(6*lat) + A8*Math.sin(8*lat));

  const easting = 500000 + k0*N*(A + (1 - T + C)*A**3/6 + (5 - 18*T + T**2 + 72*C - 58*ep2)*A**5/120);
  let northing = s + k0*N*(Math.tan(lat)*(A**2/2 + (5 - T + 9*C + 4*C**2)*A**4/24 + (61 - 58*T + T**2 + 600*C - 330*ep2)*A**6/720));
  const band = (latDeg>=0) ? 'N' : 'S';
  if (latDeg < 0) northing += 10000000;
  return {zone, band, easting:Math.round(easting), northing:Math.round(northing)};
}

function utmToLatLon(zone, band, easting, northing){
  const a=WGS84.a, e2=WGS84.e2, ep2=WGS84.ep2;
  const x = easting - 500000;
  let y = northing;
  if (band==='S') y -= 10000000;
  const lambda0 = ((zone*6 - 183) * Math.PI/180);
  // Footpoint latitude
  const n = WGS84.f/(2-WGS84.f);
  const A0 = 1 + (n**2)/4 + (n**4)/64;
  const A2 = (3/2)*(n - (n**3)/8 - (n**5)/64);
  const A4 = (15/16)*(n**2 - (n**4)/4 - (3*n**6)/128);
  const A6 = (35/48)*(n**3 - (5*n**5)/16);
  const A8 = (315/512)*(n**4 - (7*n**6)/32);
  const s = y / k0;
  const mu = s / (WGS84.b*A0);
  let phi1 = mu + (A2/A0)*Math.sin(2*mu) + (A4/A0)*Math.sin(4*mu) + (A6/A0)*Math.sin(6*mu) + (A8/A0)*Math.sin(8*mu);
  const sinphi1 = Math.sin(phi1), cosphi1=Math.cos(phi1), tanphi1=Math.tan(phi1);
  const N1 = a/Math.sqrt(1 - e2*sinphi1**2);
  const R1 = a*(1-e2)/Math.pow(1-e2*sinphi1**2, 1.5);
  const D = x/(N1*k0);
  const T1 = tanphi1**2;
  const C1 = ep2*cosphi1**2;
  const lat = phi1 - (N1*tanphi1/R1)*( D**2/2 - (5 + 3*T1 + 10*C1 - 4*C1**2 - 9*ep2)*D**4/24 + (61 + 90*T1 + 298*C1 + 45*T1**2 - 252*ep2 - 3*C1**2)*D**6/720 );
  const lon = lambda0 + ( D - (1 + 2*T1 + C1)*D**3/6 + (5 - 2*C1 + 28*T1 - 3*C1**2 + 8*ep2 + 24*T1**2)*D**5/120 )/cosphi1;
  return {lat: lat*180/Math.PI, lon: lon*180/Math.PI};
}

function haversine(lat1, lon1, lat2, lon2){
  const R = 6371000;
  const toRad = x => x*Math.PI/180;
  const dlat = toRad(lat2-lat1);
  const dlon = toRad(lon2-lon1);
  const a = Math.sin(dlat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dlon/2)**2;
  return 2*R*Math.asin(Math.sqrt(a));
}

async function loadConfig(){
  const res = await fetch('config.json', {cache:'no-store'});
  if(!res.ok) throw new Error('Impossibile caricare config.json');
  const cfg = await res.json();
  return cfg.targets;
}

function show(msg, cls){
  const el = document.getElementById('esito');
  el.className = 'status ' + (cls||'');
  el.textContent = msg;
}

document.getElementById('btn').addEventListener('click', async () => {
  try{
    show('Lettura della posizione in corso…');
    const targets = await loadConfig();
    const pos = await new Promise((resolve,reject)=>{
      navigator.geolocation.getCurrentPosition(resolve, reject, {enableHighAccuracy:true, timeout:15000, maximumAge:0});
    });
    const {latitude, longitude, accuracy} = pos.coords;
    const utm = latLonToUTM(latitude, longitude);
    document.getElementById('coord').textContent = `${utm.zone}${utm.band} ${utm.easting} ${utm.northing} (±${Math.round(accuracy)} m)`;

    // compute distance to each target (convert target UTM -> lat/lon, then Haversine)
    let best = null;
    for(const t of targets){
      const latlon = utmToLatLon(parseInt(t.zone,10), t.band, t.easting, t.northing);
      const d = haversine(latitude, longitude, latlon.lat, latlon.lon);
      if(!best || d < best.d) best = {t, d};
    }

    if(best && best.d <= 30){
      show(`✅ Sei entro ${Math.round(best.d)} m da “${best.t.name}”. CODICE: ${best.t.code}`, 'ok');
    }else{
      const msg = best ? `❌ Non sei entro 30 m di un punto. Distanza minima rilevata: ${Math.round(best.d)} m.` : '❌ Nessun punto obiettivo trovato.';
      show(msg, 'bad');
    }
  }catch(err){
    show('Errore: ' + (err.message || err), 'bad');
  }
});
</script>
</body>
</html>
